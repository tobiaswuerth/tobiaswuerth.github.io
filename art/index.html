<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="light" />
    <title>Image Gallery • Tobias Würth</title>
    <style>
        :root {
            --bg: #e6e6db;
            --text: #111;
            --muted: #6b7280;
            --border: #e5e7eb;
            --card: #fff;
            --radius: 6px;
            --gap: 8px;
            --cols: 4;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        }

        header {
            position: sticky;
            top: 0;
            z-index: 10;
            background: linear-gradient(#fff, rgba(255, 255, 255, .92));
            backdrop-filter: saturate(1.2) blur(6px);
            border-bottom: 1px solid var(--border);
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 14px 18px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .title {
            font-weight: 600;
        }

        .subtitle {
            color: var(--muted);
            font-size: 13px;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .controls input {
            width: 80px;
        }

        main {
            margin: 0 auto;
            padding: 16px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(var(--cols), minmax(0, 1fr));
            gap: var(--gap);
            container-type: inline-size;
        }

        .figure {
            margin: 0;
            overflow: hidden;
            border-radius: var(--radius);
            background: var(--card);
            position: relative;
        }

        .figure picture,
        .figure img {
            display: block;
            width: 100%;
            aspect-ratio: 1/1;
        }

        .figure img {
            height: 100%;
            object-fit: cover;
            transition: filter 0.3s ease, transform 0.3s ease, opacity 0.3s ease;
        }

        .img-loading {
            filter: blur(4px);
            transform: scale(1.02);
            opacity: 0.9;
        }

        .img-loaded {
            filter: blur(0);
            transform: none;
            opacity: 1;
        }

        .img-error {
            background: var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--muted);
            font-size: 12px;
        }

        .loading-spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-top: 2px solid var(--text);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            opacity: 0.7;
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        .error-message {
            color: #dc2626;
            background: #fef2f2;
            padding: 12px 16px;
            border-radius: var(--radius);
            border: 1px solid #fecaca;
            margin: 16px 0;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            .controls {
                align-self: stretch;
                justify-content: space-between;
            }
        }
    </style>
</head>

<body>
    <header>
        <div class="container">
            <div>
                <div class="title">Gallery</div>
                <div class="subtitle">Tobias Würth</div>
            </div>
            <div class="controls" aria-label="Layout controls">
                <label for="cols">Columns</label>
                <input id="cols" type="range" min="1" max="10" step="1" value="4" />
                <span id="colsOut">4</span>
            </div>
        </div>
    </header>

    <main>
        <h4 id="loading">Loading gallery...</h4>
        <div id="grid" class="grid" aria-live="polite"></div>
    </main>

    <script>
        class ImageGallery {
            constructor() {
                this.LIST_URL = 'assets/images.txt';
                this.WIDTHS = [128, 256, 512, 1024, 1536, 2048];
                this.SIZES = "calc((100cqw - (var(--cols) - 1) * var(--gap)) / var(--cols))";
                
                this.imageObserver = null;
                this.resizeObserver = null;
                this.imageStates = new Map(); // Track loading states
                this.loadingQueue = new Set(); // Prevent duplicate loads
                
                this.init();
            }

            q(selector) {
                return document.querySelector(selector);
            }

            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            buildSrcset(name, ext) {
                return this.WIDTHS.map(w => `assets/${name}/${name}-${w}.${ext} ${w}w`).join(', ');
            }

            async preloadImage(src) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error(`Failed to load ${src}`));
                    img.src = src;
                });
            }

            createCard(name) {
                const figure = document.createElement('figure');
                figure.className = 'figure';

                const link = document.createElement('a');
                link.href = `assets/${name}/${name}-2048.jpg`;
                link.target = "_blank";
                link.rel = "noopener";
                link.setAttribute('aria-label', `View high resolution image: ${name}`);

                const picture = document.createElement('picture');
                const img = document.createElement('img');
                
                // Start with LQIP
                Object.assign(img, {
                    src: `assets/${name}/${name}-lqip.jpg`,
                    alt: `Photo: ${name}`,
                    decoding: "async",
                    loading: "lazy",
                    className: "img-loading",
                });
                
                img.dataset.name = name;
                img.dataset.state = 'lqip';

                // Add loading spinner
                const spinner = document.createElement('div');
                spinner.className = 'loading-spinner';
                spinner.setAttribute('aria-hidden', 'true');

                picture.appendChild(img);
                link.appendChild(picture);
                figure.appendChild(link);
                figure.appendChild(spinner);

                // Initialize state
                this.imageStates.set(name, {
                    element: img,
                    figure: figure,
                    spinner: spinner,
                    state: 'lqip',
                    upgraded: false
                });

                return figure;
            }

            async upgradeToHiRes(name) {
                const state = this.imageStates.get(name);
                if (!state || state.upgraded || this.loadingQueue.has(name)) {
                    return;
                }

                this.loadingQueue.add(name);
                state.spinner.style.display = 'block';

                try {
                    const img = state.element;
                    const picture = img.parentElement;

                    // Create and setup sources for modern formats
                    const avifSource = document.createElement('source');
                    avifSource.type = "image/avif";
                    avifSource.srcset = this.buildSrcset(name, 'avif');
                    avifSource.sizes = this.SIZES;

                    const webpSource = document.createElement('source');
                    webpSource.type = "image/webp";
                    webpSource.srcset = this.buildSrcset(name, 'webp');
                    webpSource.sizes = this.SIZES;

                    // Preload the main image to ensure smooth transition
                    const mainSrc = `assets/${name}/${name}-1024.jpg`;
                    await this.preloadImage(mainSrc);

                    // Add sources to picture element
                    picture.prepend(avifSource, webpSource);

                    // Setup the main img element
                    img.sizes = this.SIZES;
                    img.srcset = this.buildSrcset(name, 'jpg');

                    // Wait for the new image to load
                    await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => reject(new Error('Load timeout')), 10000);
                        
                        const onLoad = () => {
                            clearTimeout(timeout);
                            img.removeEventListener('load', onLoad);
                            img.removeEventListener('error', onError);
                            resolve();
                        };
                        
                        const onError = () => {
                            clearTimeout(timeout);
                            img.removeEventListener('load', onLoad);
                            img.removeEventListener('error', onError);
                            reject(new Error('Image load failed'));
                        };

                        img.addEventListener('load', onLoad, { once: true });
                        img.addEventListener('error', onError, { once: true });
                    });

                    // Smooth transition to sharp image
                    img.classList.remove('img-loading');
                    img.classList.add('img-loaded');
                    
                    state.upgraded = true;
                    state.state = 'loaded';
                    state.spinner.style.display = 'none';

                    // Unobserve since we're done
                    if (this.imageObserver) {
                        this.imageObserver.unobserve(img);
                    }

                } catch (error) {
                    console.warn(`Failed to upgrade image ${name}:`, error);
                    this.handleImageError(name);
                } finally {
                    this.loadingQueue.delete(name);
                }
            }

            handleImageError(name) {
                const state = this.imageStates.get(name);
                if (!state) return;

                state.element.classList.remove('img-loading');
                state.element.classList.add('img-error');
                state.spinner.style.display = 'none';
                state.state = 'error';
                
                // Show error message
                state.element.alt = `Failed to load image: ${name}`;
            }

            setupObserver() {
                if (this.imageObserver) {
                    this.imageObserver.disconnect();
                }

                this.imageObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const name = entry.target.dataset.name;
                            if (name) {
                                this.upgradeToHiRes(name);
                            }
                        }
                    });
                }, { 
                    rootMargin: '50px',
                    threshold: 0.1
                });
            }

            calculateOptimalColumns() {
                const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
                if (vw < 480) return 1;
                if (vw < 768) return 2;
                if (vw < 1024) return 3;
                if (vw < 1440) return 4;
                return Math.min(6, Math.floor(vw / 280));
            }

            setupControls() {
                const grid = this.q('#grid');
                const colsInput = this.q('#cols');
                const colsOut = this.q('#colsOut');
                
                if (!grid || !colsInput || !colsOut) return;

                // Set up responsive max columns
                const updateMaxCols = () => {
                    const maxCols = Math.min(10, this.calculateOptimalColumns() * 2);
                    colsInput.max = String(maxCols);
                };

                updateMaxCols();

                // Get saved preference or calculate default
                const saved = parseInt(localStorage.getItem('gallery-cols') || '', 10);
                const defaultCols = this.calculateOptimalColumns();
                const initialCols = (Number.isFinite(saved) && saved >= 1 && saved <= 10) ? saved : defaultCols;

                const applyCols = (value) => {
                    const cols = Math.max(1, Math.min(10, parseInt(value, 10) || 1));
                    grid.style.setProperty('--cols', String(cols));
                    colsOut.textContent = String(cols);
                    localStorage.setItem('gallery-cols', String(cols));
                    colsInput.value = String(cols);
                };

                applyCols(initialCols);

                // Debounced input handler
                const debouncedApply = this.debounce((value) => {
                    applyCols(value);
                }, 100);

                colsInput.addEventListener('input', (e) => {
                    debouncedApply(e.target.value);
                });

                // Responsive resize handler
                if (window.ResizeObserver) {
                    this.resizeObserver = new ResizeObserver(this.debounce(() => {
                        updateMaxCols();
                    }, 250));
                    this.resizeObserver.observe(document.body);
                }
            }

            showError(message) {
                const main = this.q('main');
                if (!main) return;

                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.textContent = message;
                main.appendChild(errorDiv);
            }

            async loadImageList() {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000);

                    const response = await fetch(this.LIST_URL, { 
                        cache: 'no-store',
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const text = await response.text();
                    const images = text
                        .split(/\r?\n/)
                        .map(line => line.trim())
                        .filter(Boolean)
                        .filter(name => /^[a-zA-Z0-9_-]+$/.test(name)); // Basic validation

                    if (images.length === 0) {
                        throw new Error('No valid images found in the list');
                    }

                    return images;

                } catch (error) {
                    if (error.name === 'AbortError') {
                        throw new Error('Request timed out - please check your connection');
                    }
                    throw error;
                }
            }

            async init() {
                try {
                    const loadingEl = this.q('#loading');
                    const grid = this.q('#grid');
                    
                    if (!grid) {
                        throw new Error('Grid element not found');
                    }

                    // Load image list
                    const images = await this.loadImageList();
                    
                    // Setup intersection observer
                    this.setupObserver();

                    // Create cards
                    const fragment = document.createDocumentFragment();
                    
                    images.forEach(name => {
                        try {
                            const figure = this.createCard(name);
                            fragment.appendChild(figure);
                            
                            // Observe the image for lazy loading
                            const state = this.imageStates.get(name);
                            if (state && this.imageObserver) {
                                this.imageObserver.observe(state.element);
                            }
                        } catch (error) {
                            console.warn(`Failed to create card for ${name}:`, error);
                        }
                    });

                    // Add all cards to the grid at once
                    grid.appendChild(fragment);
                    
                    // Remove loading message
                    if (loadingEl) {
                        loadingEl.remove();
                    }

                    // Setup controls
                    this.setupControls();

                    console.log(`Gallery initialized with ${images.length} images`);

                } catch (error) {
                    console.error('Gallery initialization failed:', error);
                    
                    const loadingEl = this.q('#loading');
                    if (loadingEl) {
                        loadingEl.textContent = 'Failed to load gallery';
                    }
                    
                    this.showError(`Gallery could not be loaded: ${error.message}`);
                }
            }

            // Cleanup method for proper resource management
            destroy() {
                if (this.imageObserver) {
                    this.imageObserver.disconnect();
                }
                if (this.resizeObserver) {
                    this.resizeObserver.disconnect();
                }
                this.imageStates.clear();
                this.loadingQueue.clear();
            }
        }

        // Initialize gallery when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => new ImageGallery());
        } else {
            new ImageGallery();
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (window.gallery) {
                window.gallery.destroy();
            }
        });
    </script>
</body>

</html>